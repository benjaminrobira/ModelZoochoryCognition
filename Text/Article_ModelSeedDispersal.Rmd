---
title: "Eco-evolutionary feedback loops between animal cognition, movement and resource distribution"
# The role of animal cognition in shaping resource distribution via zoochory
# date: "`r format(Sys.time(), '%B %d, %Y')`"

#I follow: https://stackoverflow.com/questions/52918716/authors-and-affiliations-in-the-yaml-of-rmarkdown for author display
author: 
  - name: Benjamin Robira
    email: benjamin.robira@normalesup.org
    institute: FEM
    correspondence: true
institute:
  - FEM: Animal Ecology Unit, Research and Innovation Centre, Fondazione Edmund Mach, San Michele all' Adige, TN, Italy

output: 
 #      - '--lua-filter=scholarly-metadata.lua'
 #      - '--lua-filter=author-info-blocks.lua'
 bookdown::pdf_document2:
   number_sections: true
   toc: false
   citation_package: biblatex
   latex_engine: pdflatex
   fig_caption: true
   pandoc_args:
     - '--lua-filter=../scholarly-metadata/scholarly-metadata.lua'
     - '--lua-filter=../author-info-blocks/author-info-blocks.lua'
always_allow_html: true

bibliography: bibliographyarticlepackage.bib
biblio-style: apa
biblatexoptions: [natbib=true, sorting=nyt, uniquename=false, uniquelist=false]

urlcolor: gray
filecolor: gray
linkcolor: gray
fontsize: 12pt

header-includes:
  #Emoticone
  - \usepackage{fontawesome5}
  #Customise page
  - \usepackage{fancyhdr}
  - \usepackage{lastpage} #Number of lastpage
  #- \pagenumbering{gobble} #for no page numbering
  - \usepackage{pdfpages}
  # #Underline text
  # - \usepackage{ulem}
  #For graybox
  - \usepackage{tcolorbox}
  #For pictures, drawing...
  - \usepackage{tikz}
  #For title sections
  - \usepackage{titlesec}
  #Lettrine
  - \usepackage{lettrine}
  #Customise legend figure
  - \usepackage[rightcaption]{sidecap}
  - \usepackage{graphicx}
  - \usepackage{subcaption}
  - \usepackage{floatrow}
  - \usepackage{caption}
  #Multiple columns
  - \usepackage{multicol}
  #To have lines around title
  - \usepackage{titling}
  - \pretitle{
    \begin{flushleft}
    \rule[-0.15in]{0.25\linewidth}{0.8ex}
    \vspace{-0.8ex}
    \hrule
    \vspace{0.3in}
    \begin{LARGE}
    \noindent
    \textbf
    }
  - \posttitle{
    \end{LARGE}\newline
    \rule[-0.15in]{0.25\linewidth}{0.8ex}
    \hrule
    \end{flushleft}
    \vspace{0.2in}}
  - \usepackage{lettrine}  
  #- \usepackage[nolists, nomarkers,tablesfirst]{endfloat} # For figures and tables at end
  - \usepackage{lineno} # For line numbering
  - \linenumbers # For line numbering
  #- \usepackage{setspace}\doublespacing
  - \usepackage{fontawesome} #for fa symbols
  - \usepackage{tcolorbox}
  #- \pagenumbering{gobble} #for no page numbering
  - \setlength{\parskip}{0em} #to remove line gaps
  #- \setlength{\parindent}{2em} #to indent new paragraph
  - \DeclareUnicodeCharacter{2212}{-}
  - \usepackage{caption}
  - \captionsetup[figure]{font=small}
  - \newcommand{\beginsupplement}{
    \setcounter{table}{0}  
    \renewcommand{\thetable}{A\arabic{table}} 
    \setcounter{figure}{0} 
    \renewcommand{\thefigure}{A\arabic{figure}}
    } 
---

```{r child = 'layout.Rmd'}
```

```{r setup, include=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(
  include = FALSE,
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
knitr::opts_chunk$set(dpi = 300) # Figure resolution and size out.width = '100%',
knitr::opts_chunk$set(fig.pos = 'p')#, fig.align = 'center') # Places figures on pages separate from text, centered
knitr::opts_chunk$set(fig.env = "figure") # Latex figure environment
knitr::opts_knit$set(eval.after = "fig.cap") #To insert R code into R figure caption
                      
#My toolbox with several functions
source("../Scripts/R/toolbox.R")

#Libraries used
library(png)
library(ggplot2)
library(scales)
library(ggpubr)

#Updating bibliography
citeR(
bibliographyArticle = "../Text/libraryMdf.bib",
bibliographyOutput = "../Text/bibliographyarticlepackage.bib",
Rcpp,
cccd,
gwfa,
ape,
igraph,
adehabitatLT
)

#Load environment for parametrisation
load("../Renvironment/resultsTestIndex2.RData")
load("../Scripts/R/Parameterisation.RData")
percentToAssumeDifference = 5

#Set theme for all graphs
theme_set(
  theme_bw() +
  theme(axis.title = element_text(face = "bold", size = 16),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 12, face = "bold"),
        panel.grid.minor = element_line(colour = "grey93"),
        panel.grid.major = element_line(colour = "grey93"),
        strip.background = element_rect(colour = "white",
                                        fill = "white"),
        strip.text = element_text(face = "bold", size = 14))
)

```

\captionsetup{list=no}

\newpage

```{r}
words <- RmdWords("Article_ModelSeedDispersal.Rmd")
```

:::: {.graybox data-latex=""}

**Abstract |** Cognition can shape the movement of animals such as for frugivores. As frugivores can be involved in the life cycle of plants, for example in seed dispersal (i.e. zoochory), their cognition could also shape resource distribution patterns. As resource distribution patterns are known to affect the benefits of cognition, this could create eco-evolutionary feedback loops between animal cognition and the spatio-temporal patterns of resources. Using an agent-based model simulating the foraging behaviour of a frugivorous seed disperser endowed with spatio-temporal knowledge of resource distribution, we investigated whether resource spatio-temporal patterns could be influenced by the level of cognition involved in foraging. This level of cognition represented how well resource location and phenology were predicted by the agent. 

We showed that ... sentence on the consequence of cognitive foraging on resource distribution  
This stems from the conjunction of two forces: competition for space between trees and a seed-dispersal forager moving from tree to tree based on spatio-temporal memory.  
The engineering of the resource landscape was eventually beneficial/detrimental to the forager...  
Altogether, this study highlights...

<!-- the more organised the resource distribution forming routes of phenologically correlated trees. -->

\hfill

\faTags \hspace{0.01in} **Keywords:** Agent-based model - Cognition - Foraging - Frugivory - Movement - Phenology - Seed dispersal

<!-- TC:ignore -->
\faInfoCircle  \hspace{0.01in} **Word Count:** `r words$num_words` \newline
<!-- Character Count: `r words$num_char` -->
<!-- TC:endignore --> 

::::

\newpage

\tableofcontents

\newpage

# Introduction

[TO BE UPDATED]

\initial{\textcolor{black}{I}}ntroduce with:  




In the theatre of the rainforest, an evolutionary play takes place in an
unchanging setting, or so current hypotheses on the evolution of foragers’ cognition
assume (Rosati, 2017). If the protagonists, the foragers, are likely to have their
cognition shaped by the distribution of resources (Grove, 2013; Robira et al., 2021),
the characteristics of the resources themselves could be the result of forager-induced
selection (Chapman et al., 2013; John et al., 2016; Lomáscolo & Schaefer, 2010). For
example, fruit-eating primates tend to forage on trees that produce the highest quality
fruit (e.g. the sweetest fruit, Ban et al., 2014; Ban et al., 2016) and in the greatest
quantity (Flörchinger et al., 2010). Therefore, the evolutionary history of resources
and associated foragers, as in the angiosperms/primates dyad, may be joint (Fuzessy
et al., 2022; Gómez & Verdú, 2012; Lim et al., 2021; Sussman, 1991). 


Lomáscolo, S. B., & Schaefer, H. M. (2010). Signal convergence in fruits: A result of selection
by frugivores? Journal of Evolutionary Biology, 23 (3), 614–624. https://doi.org/10.
1111/j.1420-9101.2010.01931.x

Flörchinger, M., Braun, J., Böhning-Gaese, K., & Schaefer, H. M. (2010). Fruit size, crop
mass, and plant height explain differential fruit choice of primates

Fuzessy, L., Silveira, F. A., Culot, L., Jordano, P., & Verdú, M. (2022). Phylogenetic congruence between Neotropical primates and plants is driven by frugivory. Ecology Letters, 25 (2), 320–329. https://doi.org/10.1111/ele.13918

Gómez, J. M., & Verdú, M. (2012). Mutualism with plants drives primate diversification.
Systematic Biology, 61 (4), 567–577. https://doi.org/10.1093/sysbio/syr127

Sussman, R. W. (1991). Primate origins and the evolution of angiosperms. American Journal
of Primatology, 23 (4), 209–223. https://doi.org/10.1002/ajp.1350230402

Lim, J. Y., Wasserman, M. D., Veen, J., Després-Einspenner, M. L., & Kissling, W. D.
(2021). Ecological and evolutionary significance of primates’ most consumed plant
families. Proceedings of the Royal Society B: Biological Sciences, 288 (1953). https:
//doi.org/10.1098/rspb.2021.0737






§1) The effect of resource distribution on foragers' cognition
-> Cognition enhances foraging movement  
-> Cognition is promoted by specific spatial distribution.  
-> Fix setting (only short term dynamism - because fix during an individual lifetime), but in reality, interaction is two ways  

§2) possible consequence of forager on resource distribution
  -> It can affect the spatial distribution:  
  The dispersal way is affecting the distribution.  
  Pooping areas preference -> spatial aggregation  
  The use of memory is associated to the emergence of route, as suggested from theoretical (Louise) to empirical evidence.  
  Route distribution: elephants' route are following gradient. What comes first, following or gradient born from route?  
  -> It can affect the temporal distribution:


Note biblio:
seed dispersal and personality   
https://www.pnas.org/doi/full/10.1073/pnas.2113870119  
https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2435.13583  
seed dispersal and animal behaviour  
https://link.springer.com/article/10.1007/s00442-005-0178-1  
seed dispersla animal cognition  
https://link.springer.com/article/10.1007/s11258-016-0652-3  
https://onlinelibrary.wiley.com/doi/full/10.1111/j.1469-185X.2012.00250.x  
https://onlinelibrary.wiley.com/doi/full/10.1111/brv.12377  
https://repositories.lib.utexas.edu/bitstream/handle/2152/68127/ADDIS-DISSERTATION-2017.pdf?sequence=1  

A la mobilité du frugivore s'oppose la sessilité des ressources.


|   The two-way interaction between frugivore and fruit plants therefore [questionne, necessite une meilleure comprehension] of their joint history [REF]. 
Primates, for instance, have boomed in the late 


-> the possible joint history, ref to fuzessy
-> question ISS

In the case of retroaction between frugivore movement, cognition and resource distribution, an extreme scenario is illustrated in Figure \ref{fig:predictions}. Initially, assuming a parcimonious homogeneous distribution, long-term spatio-temporal memory is only marginally advantageous [REF]. As it is nonetheless, cognition should be selected. Through zoochory, deliberate targeting of some resource patches over others should initiate a change in resource distribution (e.g. increasing patchiness), eventually making cognition more and more advantageous. Over time, by repeatedly targeting the same trees, the routes used by the foragers may begin to materialise due to the seeds scattered along the way. However, in doing so, foragers who can only passively follow these routes may also start to become very efficient: they should not even have to bear the cost of high cognitive abilities, putting them at an advantage over foragers bearing the burden of cognition [REF]. While the pattern of resource distribution can be maintained, given that the routes are equally used by all foragers (yet because of two different proximal mechanisms: long-term memory vs. taxis), cognition could even start to be counter-selected. However, in the absence of concrete evidence, such a scenario remains a fable. In this study, we propose to provide a basis for discussing its realism, based on computer simulations that mimic the foraging behaviour of an agent endowed with spatio-temporal knowledge of resource spatial distribution and phenology and the rool of seed-disperser.

```{r predictions, echo = FALSE, message = FALSE, include = TRUE, fig.align = 'center', fig.cap='Theoretical expectations on eco-evolutionary feedback loops between animal movement cognition and resource distribution', out.width = '0.95\\linewidth'}
knitr::include_graphics("../FIG/summaryPredictions.pdf")

```

<!-- When Alice ran together with the Red Queen, she remained at the same spot. It is because %SPEECH OF THE RED QUEEN%. This picture was applied to evolutionary scenarios, in which species evolve together. -->

<!-- Animals are living in changing world. This dynamism is subject to cognitive selection. -->

<!-- Yet, despite such a bipartite framework, with animal and (plant) resource, current research discarded evolution of both side. Most papers actually discard dynamism (e.g. mine), some consider competition between individuals but static memory (e.g. louise), and some consider dynamic memory (e.g. associative memory royal society paper lindt I think etc.). Yet, an animal might act upon its own environment too. -->

# Material and Methods

## Agent-based model

The main objective of the model was to simulate the foraging behaviour of a single agent in an environment dynamical both on the short term, through an interplay between resource growth and depletion, and on the long term, due to seed dispersal. For simplicity, we will refer to the agent as the forager, and to resource patches as trees, but this model should find larger resonance. The model was implemented in the *Rcpp* language in *R* software [`r extractRversion()`, @Rsoftware]  based on the *Rcpp* package [@Rcpp1; @Rcpp2; @Rcpp3].

<!-- Statistical significance was assumed considering the nominal threshold of significance $\alpha=0.05$. -->

### Environment

#### Spatial distribution

We modelled the environment as a flat square map of side `r mapSize` arbitrary spatial units (su). Within this map, `r numberTrees` trees were initially homogeneously distributed (uniform distribution of their $x$ and $y$ coordinates, resulting in a Poisson distribution of tree density).

#### Resource growth

Time was cyclical, with a period of `r cycleLength` arbitrary time units (tu). Each tree could produce resource (fruit containing seeds) for `r fruitingLength` tu only once every period. Thus, resource was seasonal at the tree-level, but not at the map-level. Periods of productivity of each tree were randomly distributed (i.e. uniform distribution of the start date). Productivity was characterised by a triangular-shaped pattern of the quantity of food along time: at start of the productive period, food quantity started to increase linearly up to `r maxFoodToYield` arbitrary food unit (fu), mimicking progressive fruit ripening, and then decreased linearly to 0 fu, mimicking fruit rotting. At a given time, the quantity of food available at a given tree thus depended on the productivity of the tree at that time, as well as the depletion history by the agent, creating a short-term dynamics of resource temporal distribution.

#### Seed dispersal

Trees could reproduce and disperse via fruit eaten by the agent. Once the agent ate on ripe fruit, seeds could be dispersed once up to `r timeDelayForDispersal` tu after ingestion, with a probability of `r DispersalProbability/timeDelayForDispersal` tu$^{-1}$, independent of the quantity of fruit ingested, for simplicity. Thus, all fruit eaten did not mandatorily led to dispersal. Dispersal was eventually successful only if some space was left available for the new tree. This means that no tree had to be at a distance lower than `r round(0.80 * sqrt(mapSize * mapSize / (numberTrees * pi)), digits = 2)` su. This number was obtained such as the exclusive "lifespace" by trees (a circular area of radius the aforementioned distance) was equal to 80% of the map area. If it happened that there was available space for the seedling to grow, then the seedling location was sampled in the available space along the linear path linking the previous target. Otherwise, the seedling could not grow and died. 

<!-- If considering buffer for dispersal: -->
<!-- and the current one buffer by the sensory range of the agent (`r round(perceptualRange)` su) -->

|   If the seedling was successfully dispersed and lived, an old tree (already present in the map) was randomly selected and died to keep density constant. The start date of fruiting of the new-born was randomly sampled within a reduced Gaussian distribution (i.e. variance of one) centered on the start date of fruiting of the parent tree. The location and fruiting timing of the new-born tree were memorised if it replaced a tree that was part of the agent's memory. The new-born tree was considered as mature only the year after. Seed dispersal could thus induce a long-term dynamics of resource spatial distribution and of the distribution of starting dates in the tree population.

### Agent

#### Cognitive abilities

The forager was endowed with a gradient of knowledge abilties: from no memory of the locations of trees (naive forager) and the timing of their period of productivity to perfect omniscience (i.e. all tree locations are known) and prescience (i.e. all periods of productivity are known). In case a tree was part of the forager's memory, the forager knew both the spatial (location) and temporal (fruiting timing) attributes. Thus, it could not know only one or the other. In case of partial knowledge, known trees were randomly selected at start.

<!-- trees growing from successful seedlings were memorised, as well as trees that were visited while fruiting. In this case, they replaced known trees that were visited the longest time ago. To maintain the spatio-temporal knowledge rate constant, each time a new tree location and associate fruiting dates were memorised, those of the tree visited the longest time ago were forgotten. -->

#### Moving rules

The forager was initially randomly located within the map. It is fully aware of trees present within sensory range fixed to `r round(perceptualRange, digit=2)` su. This actually corresponds to the average nearest-neighbour distance which equates $1/(2\sqrt{\rho})$, with $\rho$ the density of trees (here `r numberTrees/mapSize/mapSize`) at start of the simulation where trees are homogeneously distributed. It is also aware of trees part of its spatio-temporal long-term memory. To decide where to head next, the forager could either rely on its private knowledge (sensory or memory) or not. If all trees within its private knowledge did not yield any fruit (i.e., all having less than 0.001 fu), the forager was moving randomly. Random movements were performed by randomly choosing a direction (uniform distribution of the heading angle), while the step length was sampled within an exponential distribution of mean $\lambda_{step\,length}$ = `r exponentialRate`. An exponential distribution of step lengths is indeed classically observed in nature [REF]. Otherwise, the agent targeted the `r whatRule` tree which maximised the ratio between the predicted food quantity at the tree (which accounts for depletion history), and the distance to the tree. Nonetheless, the forager avoided to target trees recently visited within the previous `r noReturnTime` tu to avoid targeting recently depleted trees [@robirainreview]. 

|   Once the target had been chosen (or random point, if none), the forager moved straight to the first tree that should have been theoretically perceived *en route* to the initial destination point if any (provided they were not recently visited), or the destination otherwise. When this destination is reached, it then re-estimated the best tree to target and so on. Such a movement roughly mimics a beacon/landmark-based navigation, where individuals individuals move from beacon to beacon to reach a target [REF] and frames coherently with the tendency of individuals to monitor resource state while moving [REF]. After each moving bout time was updated based on the distance travelled, knowing that the forager moved at a speed of `r speed` su/tu. Then, the resource quantity available at each tree was updated. 

|   In case all trees were empty (no food available in the environment, considered if sum of food available was less than 1 fu), the forager entered a torpor period for `r torporTime` tu, and so on until food was available again. This was done to avoid biasing measure of foraging efficiency in case the forager could deplete entirely the environment while being unable to disperse to another area, as expected in nature if this happens. 

```{r modelParametersTable, include=TRUE}
library(kableExtra)
options(knitr.kable.NA = "-")
parametersValue[parametersValue[, 5] == "", 5] <- NA
knitr::kable(parametersValue, escape = TRUE, booktabs = TRUE, longtable = TRUE,
             caption = "Model parameters", align = "lllcccc") %>%
  kableExtra::kable_styling(latex_options = "striped") %>%
  kableExtra::landscape() %>%
  kable_styling(font_size = 7, full_width = FALSE)

# library(huxtable)
# as_huxtable(parametersValue) %>%
#   set_caption("Model parameters") %>%
#   add_colnames() %>% 
# #Main layout
# set_bottom_border(row = 1, col = everywhere) %>%
# set_bold(row = 1, col = everywhere) %>%
# set_background_color(evens, everywhere, "grey95") %>%
# as_flextable() #%>% 
#   # flextable::autofit() %>% 
#   # flextable::set_table_properties(layout = "autofit")

``` 

## Analyses

### Characterisation of tree distribution patterns 

To assess whether different levels of cognition resulted in different organisation of the spatial distribution of trees at the end of the simulation we focused on three metrics describing the tree spatio-temporal patterns: the *patchiness*, the *alignment* and the *spatial autocorrelation of fruiting timing*.

<!-- the *pseudo fractal dimension*, the *reticulation* -->

#### Patchiness

Patchiness (i.e. the tendency of trees to aggregate into clusters) was measured using Lloyd's index of patchiness [@lloyd1967mean]. This index is given by the following formula

\begin{center}

\hfill

$P=\frac{N_{quadrat}\sum_{i}{n_{i}(n_{i}-1)}}{(\sum_{i}{n_{i}})^2}$

\hfill

\end{center}

where $n_{i}$ represents the number of trees in quadrat *i* and $N_{quadrat}$ the number of quadrats. The map was divided in 400 square quadrats of side 50 su. The quadrat size, provided sufficient length for biological relevance, little affects the measurement [@lloyd1967mean]. Lower values indicate homogeneous distribution while larger values indicate heterogeneous and route distributions [(see Appendix Material)][Using patchiness and alignment to characterise spatial point patterns].


<!-- -> TO CHECK IN LLOYD PUBLICATION. I AM NOW UNSURE GIVEN THAT IT DOES WHEN I VARY THE SIZE ON SIMULATED DISTRIB. -->

<!-- 50 su was chosen because it corresponded to the lowest value before Lloyd's index of patchiness stabilised given our tree density and map size (see Appendix [Quadrat size estimation]). NOT TRUE? Why? I believed Lloyd said was insensitive to quadrat size. To verify -->

<!-- #### Pseudo-fractal dimension -->

<!-- Pseudo fractal dimension (i.e. the tendency of trees to organise in patterns insensitive to observation scale) was calculated based on a Geographically Weighted Fractal Analysis [Applying two fractal methods to characterise the local and global deviations from scale invariance of built patterns throughout mainland France] specifically developed for point patterns. In brief, for points, the fractal dimension corresponds to the slope of the regression of the logarithm of the number of points around a point of interest, as a function of the radius length to consider neighbouring points. To do so, we used the "gwfa" function of the *gwfa* package [@gwfa]. We fixed the circular neighbourhood (a measure of whether the scale is local, low radius compared to the map size, or global, large radius compared to the map size) to 200 su. The pseudo-fractal dimension corresponds to the average pseudo fractal dimension of randomly sampled points (limited to 500 within cells of side 200 su), for which we varied the counting scale (i.e. circular radius around each point of interest) from 20 su to 60 su (ten regularly spaced values in total). We use the "pseudo" prefix because we did not verify whether the calculated fractal dimension is statistically significant (i.e. if the regression slope, aimed to determine the fractal dimension, indeed offers a different fit from a constant). -->

<!-- #### Reticulation -->

<!-- Reticulation (i.e. the tendency of trees to form reticulated networks) of the tree distribution was measured following Addis (2017) [https://repositories.lib.utexas.edu/bitstream/handle/2152/68127/ADDIS-DISSERTATION-2017.pdf?sequence=1]. This method is based on the Relative Neighbourhood Graph [RNG, Toussaint, G. T. 1980. The relative neighbourhood graph of a finite planar set. Pattern Recognition 12:261–268], which should reflect the intuitive perception of reticulation a human observer might have. In this graph, two points are connected by an edge if there is no third point that is closer to the two points than the two are between each other. Such a property thus drives the visualisation of "void areas" within the distribution, since it favours immediate close-distance edge. It thus likely reflects the "routes" that are paved by trees that a forager might tend to follow. -->
<!-- We constructed the RNG as an undirected and weighted graph, where the edge weight corresponded to the Manhattan distance between the two connected points ("rng" function of the *cccd* package [@cccd]). We followed Addis (2017) and defined the reticulation as   -->
<!-- \hfill -->

<!-- $R = \frac{D - M}{max(M_{i,j})}$   -->

<!-- \hfill -->

<!-- where *D* is the diameter of the RNG. This diameter corresponds to the length of the longest of the shortest paths that connect two points within the RNG. Shortest paths between each pair of points of the RNG were obtained with the "shortest.path" function of the *igraph* package [@igraph]. *M* corresponds to the Manhattan distance between the pair of points whose shortest path equates to that of the diameter (or its average, if multiple pairs could lead to the maximum diameter length), while $M_{i,j}$ corresponds to the Euclidean distance between two points *i* and *j*. Despite we are not in a grid-based system (Addis, 2017), we used the Manhattan distance because we empirically observed that this enabled us distinguishing correctly between different spatial patterns (see Appendix [What distance to calculate reticulation?]) -->

#### Tree alignment

Routes are (curvi-)linear features. To assess the tendency of trees to form linear pattern, we quantified their alignment. For a given tree, alignment *a* was defined as one minus the minimum of the sine of the angles of the triangle formed by the tree of interest and two closest trees. This varies from perfect alignment (value of 1), to no alignment (i.e., the minimum angle would be at worse 60° hence an alignment of ca. 0.134). Therefore, we use a corrected alignment $a_c$ varying from 0 (no alignment) to 1 (perfect alignment) such as

\begin{center}

\hfill

$a_{c} = \frac{a - (1 - sin(\pi/3))}{1 - (1 - sin(\pi/3))}$

\hfill

\end{center}

We used the opposite of the skewness of alignment values of all trees to describe the whole distribution. Positive values indicate the existence of linear motifs while negative values indicate no obvious linear patterns. In the simulated conditions, random distributions (homogeneous or heterogeneous) should highlight moderate positive values [(see Appendix Material)][Using patchiness and alignment to characterise spatial point patterns].

<!-- IF USING NEIGHBOURHOOD ALIGNMENT -->
<!-- other neighbouring trees. A neighbourhood was defined as a circular area of radius three times the tree lifespace (to possible have at least twice lifespace distances between the two farthest trees). If more than two trees were present, all combinations of two trees were associated to the tree of interest, and the minimum alignment among all possible combinations was eventually considered. If no tree, or only one, was found in this neighbourhood, the algorithm selected the two closest trees. -->

#### Spatial autocorrelation of fruiting timing

Spatial autocorrelation of fruiting timing (i.e. the tendency of fruiting date of trees to more closely match that of neighbours than of distant trees) was calculated as the Geary Index, \textit{C} [REF] applied to the start of fruiting dates. Since the date of start of fruiting corresponds to a circular variable, we followed [https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5870747/] to adapt existing functions of the *ape* package [@ape] to circular variables. Geary's \textit{C} was therefore defined as

\begin{center}

\hfill

$C = (N-1) \sum_{i}\sum_{j} w_{ij}d(t_i,t_j)^2 \over 2 \sum_{i,j}w_{ij}\sum_i d(x_i,\bar{t})^2$

\hfill

\end{center}

where $N$ is the number of trees, $t$ is the fruiting date (in radian), $d(t_1,t_2) = atan2(sin(t_1 - t_2), cos(t_1 - t_2))$, $\bar{t} = atan2(1/N\sum_isin(t_i), 1/N\sum_icos(t_i))$. We used the inverse of the Euclidean distance between tree locations as weights. Values of $C$ close to 1 indicate absence of spatial autocorrelation. Values close to 0 indicate negative spatial autocorrelation. Values larger than 1 indicate positive spatial autocorrelation.

### Routine emergence

For each simulation, we verified whether a routine behaviour emerged and paralleled the variations in tree distribution. We characterised routine holding on the notion of conditional entropy following [REF Riotte-Lambert] using the series of tree id targeted during five supplementary season periods in which dispersal could not occur. We computed the routine possibly up to only a first order conditional entropy, as computing routine indices is computationally demanding and a first order is expecting to be the most informative to describe a perfect traplining behaviour [REF Riotte-Lambert]. The routine index varies from 0 (no routine) to 1 (perfect traplining).

### Does resource spatio-temporal distribution vary with cognition level? 

To investigate whether different levels of cognition eventually led to different distribution patterns, we considered five forager types differing by the proportion of trees for which the location and phenology was known (from 0 to 100%, at a step of `r 100/length(spatialKnowledge)`, henceforth *spatio-temporal knowledge rate*). Each forager was first let foraging individually for `r cycleLimitNumber` seasonal periods. We repeated the simulations for a given condition (i.e. knowledge rate) `r numberRepetitions` times.
 
### Does resource distribution engineering favour some cognition levels?

To investigate whether the engineered distribution of trees could in turn affect the foraging benefices purported by cognition, we considered the final tree distributions of simulations computed to answer question 1). For each of these tree distributions, in three different simulation runs, we let forage a forager endowed with no, intermediate (i.e. half of trees known), or full (all trees known) spatio-temporal knowledge. In these simulations, no seed-dispersal could occur. We measured the foraging efficiency after the forager foraged for `r cycleLimitNumber/5` full seasons and compared them across environments and agent abilities. Foraging efficiency was computed as the cumulated quantity of eaten food, over the cumulated distance travelled. We verified that at the end of the simulation that foraging efficiency stabilised, which meant that we reached a foraging equilibrium. We considered that foraging efficiency stabilised when the foraging efficiency sampled after each moving bout during the fourth and fifth quintile of simulation times did not statistically differed of more than `r percentToAssumeDifference`% (reference is the minimum efficiency in the fourth or the fifth quintile of simulation times). Distributions of foraging efficiency measures were compared with Student tests ("t.test" function). We repeated the simulations for a given conditions (i.e. knowledge rate) `r numberRepetitions` times.

### Route formation as a product of two forces: tree competition for space and agents' movement step rule

During the model construction, we noticed that routes eventually appeared with the implementation of two mechanisms: space competition between trees and sequential targeting of all trees seen *en route* to the target. To better quantify the effect of those two forces, we considered two other sets of `r numberRepetitions` simulations each.

|   To assess the effect of competition for space between trees, we compared the final tree spatio-temporal patterns when a perfectly knowledgeable agent (all tree locations and phenology known) was let foraging in the same setting as in question 1), with the only difference that the exclusive lifespace between trees could vary be of 5 (small lifespace), 45 (intermediate lifespace) or 85% (large lifespace) of the map surface, so that the radius of this exclusive circular lifespace was at best slightly superior to the perception range (`r round(0.85 * sqrt(mapSize * mapSize / (numberTrees * pi)), digits = 2)` su vs `r round(perceptualRange, digit=2)` su).

|   To assess the effect of the movement tactic of the forager on tree distribution patterns, we compared the final tree spatio-temporal patterns when an omniscient agent was let foraging in the same setting as in question 1) and while the stringency in skipping trees encountered *en route* varied. It could either stop at all trees perceived on the way to the initial target (mimicking a "monitoring" behaviour, as in all other simulations; small skipping stringency), stop only at trees currently fruiting (i.e., with at least 0.001 fu, mimicking an opportunistic feeding only; intermediate skipping stringency) or move directly to the target (large skipping stringency).

# Results

[TO BE UPDATED]

```{r figMap, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap=""}

# -> add one figure for distribution: 
# - init, after naive agent ran, intermediate or prescient
# - init and three moving rules
# - init and three spacing

```

```{r figEngineering, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap=""}

# mergedPlotMovingRule <- read.rds("Renvironment/Plots/movingRulePlots.rds")
# mergedPlotSpaceTree <- read.rds("Renvironment/Plots/spacingTreePlots.rds")
# mergedPlotMain <- read.rds("Renvironment/Plots/mainPlots.rds")
# 
# library(ggpubr)
# plotEngineering <- ggarrange(
#   mergedPlotMain,
#   mergedPlotMovingRule,
#   mergedPlotSpaceTree,
#   ncol = 3
# )
# plotEngineering
```

```{r figChangeTime, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap=""}

# -> add one figure to see the changes in parameters along time for the different level of cognition

```

```{r figEfficiency, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap=" | The 'initial condition' of resource distribution was taken from the simulations in which a Null, Intermediate or Omniscient forager was first let foraging. Then, those three forager types were let foraging (separately) without dispersal and foraging efficiency was measured (cumulated food eaten over cumulated travelled distance)."}
# 
# plotEfficiency <- readRDS("Renvironment/Plots/efficiencyPlots.rds")
# plotEfficiency

```

### Resource distribution varies with the cognition of the seed-disperser forager

### Cognitive foraging efficiency is (not? -> awaiting results) affected by tree distribution engineering

### Route pattern emerges...

<!-- ```{r figPatchiness, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap="Patchiness is significantly affected by the seed-disperser forager cognition rate | Spatio-temporal knowledge rate indicates the proportion of trees that is known by the forager."} -->

<!-- layout(mat = t(c(1, 2)), -->
<!--        widths = c(5, 2), -->
<!--        heights = c(5, 5)) -->

<!-- par(mar = c(4, 7, 0.5, 0.5), -->
<!--     mgp = c(3.5, 1, 0), -->
<!--     xpd = TRUE) -->
<!-- #Import own function -->
<!-- source( -->
<!--   "../Scripts/R/toolbox.R", -->
<!--   local = knitr::knit_global() -->
<!-- ) -->

<!-- ###~~~~~~~~ -->
<!-- ## PATCHINESS -->
<!-- ###~~~~~~~~ -->

<!-- #transform to 2 cols table for boxplot -->
<!-- dfPatchiness <- as.data.frame(cbind( -->
<!--   as.vector(matrixPatchinessAtEnd), -->
<!--   rep(temporalKnowledge, each = numberRepetitions) -->
<!-- )) -->
<!-- colnames(dfPatchiness) <- c("Value", "Knowledge") -->

<!-- #Patchiness -->
<!-- maxy = ceiling(max(dfPatchiness$Value)) -->
<!-- miny = 0 -->

<!-- emptyPlot(xlim = c(0.5, length(temporalKnowledge) + 0.5), ylim = c(0, maxy)) -->

<!-- #add grid -->
<!-- addGrid( -->
<!--   xmin = 0.5, -->
<!--   xmax = length(temporalKnowledge) + 0.5, -->
<!--   xintsmall = 0.1, -->
<!--   xintbig = 0.5, -->
<!--   ymin = 0, -->
<!--   ymax = maxy, -->
<!--   yintsmall = (maxy - miny) / 20, -->
<!--   yintbig = (maxy - miny) / 5, -->
<!--   axisPlot = FALSE -->
<!-- )#Background grid -->

<!-- boxPlotSaved <- -->
<!--   boxplot( -->
<!--     Value ~ Knowledge, -->
<!--     data = dfPatchiness, -->
<!--     boxwex = 0.25, -->
<!--     xlab = "", -->
<!--     ylab = "", -->
<!--     cex.lab = 1.2, -->
<!--     yaxs = "i", -->
<!--     xaxs = "i", -->
<!--     las = 1, -->
<!--     tcl = -0.25, -->
<!--     frame.plot = FALSE, -->
<!--     xaxt = "n", -->
<!--     yaxt = "n", -->
<!--     outline = FALSE, -->
<!--     add = TRUE -->
<!--   ) -->


<!-- for (i in 1:length(temporalKnowledge)) { -->
<!--   #Mask half -->
<!--   rect( -->
<!--     xleft = c(i), -->
<!--     xright = c(i + 0.5), -->
<!--     ybottom = c(0, 0), -->
<!--     ytop = c(maxy, maxy), -->
<!--     col = "white", -->
<!--     border = NA -->
<!--   ) -->

<!--   #Readd grid -->
<!--   addGrid( -->
<!--     xmin = i, -->
<!--     xmax = i + 0.5, -->
<!--     xintsmall = 0.1, -->
<!--     xintbig = 0.5, -->
<!--     ymin = 0, -->
<!--     ymax = maxy, -->
<!--     yintsmall = (maxy - miny) / 20, -->
<!--     yintbig = (maxy - miny) / 5, -->
<!--     axisPlot = FALSE -->
<!--   )#Background grid -->

<!-- } -->

<!-- #Read interquartile range -->
<!-- segments( -->
<!--   x0 = c(1:length(temporalKnowledge)), -->
<!--   x1 = c(1:length(temporalKnowledge)), -->
<!--   y0 = c(boxPlotSaved$stats[1, 1:length(temporalKnowledge)]), -->
<!--   y1 = c(boxPlotSaved$stats[5, 1:length(temporalKnowledge)]) -->
<!-- ) -->

<!-- #Add jitter points + link because paired -->

<!-- dfPatchiness$Loc <- as.numeric(as.factor(dfPatchiness$Knowledge)) -->
<!-- dfPatchiness$Loc <- dfPatchiness$Loc + 0.2 -->
<!-- dfPatchiness$LocJittered <- jitter(dfPatchiness$Loc, factor = 0.5) -->
<!-- points( -->
<!--   dfPatchiness$LocJittered, -->
<!--   dfPatchiness$Value, -->
<!--   cex = 0.5, -->
<!--   pch = 19, -->
<!--   col = "grey", -->
<!--   xpd = TRUE -->
<!-- ) -->

<!-- #Add mean points -->
<!-- points( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixPatchinessAtEnd, 2, mean), -->
<!--   pch = 19, -->
<!--   cex = 1.25 -->
<!-- ) -->
<!-- text( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixPatchinessAtEnd, 2, mean) - maxy / 30, -->
<!--   labels = round(apply(matrixPatchinessAtEnd, 2, mean), digit = 2), -->
<!--   cex = 1.25 -->
<!-- ) -->

<!-- #x-axis -->
<!-- axis( -->
<!--   side = 1, -->
<!--   line = 0, -->
<!--   at = seq( -->
<!--     from = 1, -->
<!--     to = length(temporalKnowledge), -->
<!--     by = 1 -->
<!--   ), -->
<!--   labels = temporalKnowledge, -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 1, -->
<!--   line = 2.5, -->
<!--   at = (length(temporalKnowledge) + 0.5 + 0.5) / 2, -->
<!--   text = "Spatio-temporal knowledge rate", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- #y-axis -->
<!-- axis( -->
<!--   side = 2, -->
<!--   line = 0, -->
<!--   at = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   labels = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 2, -->
<!--   line = 3, -->
<!--   at = maxy / 2, -->
<!--   text = "Index of patchiness", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- par(mar = c(0, 0, 0, 0), mgp = c(2, 0.5, 0)) -->
<!-- emptyPlot() -->
<!-- patchiness_legendIMG <- readPNG("FIG/Patchiness_legend.png") -->
<!-- addImg(patchiness_legendIMG, -->
<!--        x = 0.5, -->
<!--        y = 0.5, -->
<!--        width = 0.5) -->

<!-- ``` -->

<!-- ```{r figalignment, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap="Alignment is significantly affected by the seed-disperser forager cognition rate | Spatio-temporal knowledge rate indicates the proportion of trees that is known by the forager."} -->

<!-- layout(mat = t(c(1, 2)), -->
<!--        widths = c(5, 2), -->
<!--        heights = c(5, 5)) -->

<!-- par(mar = c(4, 7, 0.5, 0.5), -->
<!--     mgp = c(3.5, 1, 0), -->
<!--     xpd = TRUE) -->

<!-- ###~~~~~~~~ -->
<!-- ## Alignment -->
<!-- ###~~~~~~~~ -->

<!-- #transform to 2 cols table for boxplot -->
<!-- dfAlignment <- as.data.frame(cbind( -->
<!--   as.vector(matrixAlignmentTestAtEnd), -->
<!--   rep(temporalKnowledge, each = numberRepetitions) -->
<!-- )) -->
<!-- colnames(dfAlignment) <- c("Value", "Knowledge") -->

<!-- #Alignment -->
<!-- maxy = ceiling(max(dfAlignment$Value)) -->
<!-- miny = 0 -->

<!-- emptyPlot(xlim = c(0.5, length(temporalKnowledge) + 0.5), ylim = c(0, maxy)) -->

<!-- #add grid -->
<!-- addGrid( -->
<!--   xmin = 0.5, -->
<!--   xmax = length(temporalKnowledge) + 0.5, -->
<!--   xintsmall = 0.1, -->
<!--   xintbig = 0.5, -->
<!--   ymin = 0, -->
<!--   ymax = maxy, -->
<!--   yintsmall = (maxy - miny) / 20, -->
<!--   yintbig = (maxy - miny) / 5, -->
<!--   axisPlot = FALSE -->
<!-- )#Background grid -->

<!-- boxPlotSaved <- -->
<!--   boxplot( -->
<!--     Value ~ Knowledge, -->
<!--     data = dfAlignment, -->
<!--     boxwex = 0.25, -->
<!--     xlab = "", -->
<!--     ylab = "", -->
<!--     cex.lab = 1.2, -->
<!--     yaxs = "i", -->
<!--     xaxs = "i", -->
<!--     las = 1, -->
<!--     tcl = -0.25, -->
<!--     frame.plot = FALSE, -->
<!--     xaxt = "n", -->
<!--     yaxt = "n", -->
<!--     outline = FALSE, -->
<!--     add = TRUE -->
<!--   ) -->


<!-- for (i in 1:length(temporalKnowledge)) { -->
<!--   #Mask half -->
<!--   rect( -->
<!--     xleft = c(i), -->
<!--     xright = c(i + 0.5), -->
<!--     ybottom = c(0, 0), -->
<!--     ytop = c(maxy, maxy), -->
<!--     col = "white", -->
<!--     border = NA -->
<!--   ) -->

<!--   #Readd grid -->
<!--   addGrid( -->
<!--     xmin = i, -->
<!--     xmax = i + 0.5, -->
<!--     xintsmall = 0.1, -->
<!--     xintbig = 0.5, -->
<!--     ymin = 0, -->
<!--     ymax = maxy, -->
<!--     yintsmall = (maxy - miny) / 20, -->
<!--     yintbig = (maxy - miny) / 5, -->
<!--     axisPlot = FALSE -->
<!--   )#Background grid -->

<!-- } -->

<!-- #Read interquartile range -->
<!-- segments( -->
<!--   x0 = c(1:length(temporalKnowledge)), -->
<!--   x1 = c(1:length(temporalKnowledge)), -->
<!--   y0 = c(boxPlotSaved$stats[1, 1:length(temporalKnowledge)]), -->
<!--   y1 = c(boxPlotSaved$stats[5, 1:length(temporalKnowledge)]) -->
<!-- ) -->

<!-- #Add jitter points + link because paired -->

<!-- dfAlignment$Loc <- -->
<!--   as.numeric(as.factor(dfAlignment$Knowledge)) -->
<!-- dfAlignment$Loc <- dfAlignment$Loc + 0.2 -->
<!-- dfAlignment$LocJittered <- jitter(dfAlignment$Loc, factor = 0.5) -->
<!-- points( -->
<!--   dfAlignment$LocJittered, -->
<!--   dfAlignment$Value, -->
<!--   cex = 0.5, -->
<!--   pch = 19, -->
<!--   col = "grey", -->
<!--   xpd = TRUE -->
<!-- ) -->

<!-- #Add mean points -->
<!-- points( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixAlignmentAtEnd, 2, mean), -->
<!--   pch = 19, -->
<!--   cex = 1.25 -->
<!-- ) -->
<!-- text( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixAlignmentAtEnd, 2, mean) - maxy / 30, -->
<!--   labels = round(apply(matrixAlignmentAtEnd, 2, mean), digit = 2), -->
<!--   cex = 1.25 -->
<!-- ) -->

<!-- #x-axis -->
<!-- axis( -->
<!--   side = 1, -->
<!--   line = 0, -->
<!--   at = seq( -->
<!--     from = 1, -->
<!--     to = length(temporalKnowledge), -->
<!--     by = 1 -->
<!--   ), -->
<!--   labels = temporalKnowledge, -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 1, -->
<!--   line = 2.5, -->
<!--   at = (length(temporalKnowledge) + 0.5 + 0.5) / 2, -->
<!--   text = "Spatio-temporal knowledge rate", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- #y-axis -->
<!-- axis( -->
<!--   side = 2, -->
<!--   line = 0, -->
<!--   at = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   labels = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 2, -->
<!--   line = 3, -->
<!--   at = maxy / 2, -->
<!--   text = "Index of Alignment", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- par(mar = c(0, 0, 0, 0), mgp = c(2, 0.5, 0)) -->
<!-- emptyPlot() -->
<!-- Alignment_legendIMG <- readPNG("FIG/Fractal_legend.png") -->
<!-- addImg(Alignment_legendIMG, -->
<!--        x = 0.5, -->
<!--        y = 0.5, -->
<!--        width = 0.5) -->

<!-- ``` -->

<!-- ```{r figgeary, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap="Spatial correlation in fruiting timing is significantly affected by the seed-disperser forager cognition rate | Spatio-temporal knowledge rate indicates the proportion of trees that is known by the forager."} -->

<!-- layout(mat = t(c(1, 2)), -->
<!--        widths = c(5, 2), -->
<!--        heights = c(5, 5)) -->

<!-- par(mar = c(4, 7, 0.5, 0.5), -->
<!--     mgp = c(3.5, 1, 0), -->
<!--     xpd = TRUE) -->

<!-- ###~~~~~~~~ -->
<!-- ## geary -->
<!-- ###~~~~~~~~ -->

<!-- #transform to 2 cols table for boxplot -->
<!-- dfgeary <- as.data.frame(cbind( -->
<!--   as.vector(matrixgearyTestAtEnd), -->
<!--   rep(temporalKnowledge, each = numberRepetitions) -->
<!-- )) -->
<!-- colnames(dfgeary) <- c("Value", "Knowledge") -->

<!-- #geary -->
<!-- maxy = ceiling(max(dfgeary$Value)) -->
<!-- miny = 0 -->

<!-- emptyPlot(xlim = c(0.5, length(temporalKnowledge) + 0.5), ylim = c(0, maxy)) -->

<!-- #add grid -->
<!-- addGrid( -->
<!--   xmin = 0.5, -->
<!--   xmax = length(temporalKnowledge) + 0.5, -->
<!--   xintsmall = 0.1, -->
<!--   xintbig = 0.5, -->
<!--   ymin = 0, -->
<!--   ymax = maxy, -->
<!--   yintsmall = (maxy - miny) / 20, -->
<!--   yintbig = (maxy - miny) / 5, -->
<!--   axisPlot = FALSE -->
<!-- )#Background grid -->

<!-- boxPlotSaved <- -->
<!--   boxplot( -->
<!--     Value ~ Knowledge, -->
<!--     data = dfgeary, -->
<!--     boxwex = 0.25, -->
<!--     xlab = "", -->
<!--     ylab = "", -->
<!--     cex.lab = 1.2, -->
<!--     yaxs = "i", -->
<!--     xaxs = "i", -->
<!--     las = 1, -->
<!--     tcl = -0.25, -->
<!--     frame.plot = FALSE, -->
<!--     xaxt = "n", -->
<!--     yaxt = "n", -->
<!--     outline = FALSE, -->
<!--     add = TRUE -->
<!--   ) -->


<!-- for (i in 1:length(temporalKnowledge)) { -->
<!--   #Mask half -->
<!--   rect( -->
<!--     xleft = c(i), -->
<!--     xright = c(i + 0.5), -->
<!--     ybottom = c(0, 0), -->
<!--     ytop = c(maxy, maxy), -->
<!--     col = "white", -->
<!--     border = NA -->
<!--   ) -->

<!--   #Readd grid -->
<!--   addGrid( -->
<!--     xmin = i, -->
<!--     xmax = i + 0.5, -->
<!--     xintsmall = 0.1, -->
<!--     xintbig = 0.5, -->
<!--     ymin = 0, -->
<!--     ymax = maxy, -->
<!--     yintsmall = (maxy - miny) / 20, -->
<!--     yintbig = (maxy - miny) / 5, -->
<!--     axisPlot = FALSE -->
<!--   )#Background grid -->

<!-- } -->

<!-- #Read interquartile range -->
<!-- segments( -->
<!--   x0 = c(1:length(temporalKnowledge)), -->
<!--   x1 = c(1:length(temporalKnowledge)), -->
<!--   y0 = c(boxPlotSaved$stats[1, 1:length(temporalKnowledge)]), -->
<!--   y1 = c(boxPlotSaved$stats[5, 1:length(temporalKnowledge)]) -->
<!-- ) -->

<!-- #Add jitter points + link because paired -->

<!-- dfgeary$Loc <- as.numeric(as.factor(dfgeary$Knowledge)) -->
<!-- dfgeary$Loc <- dfgeary$Loc + 0.2 -->
<!-- dfgeary$LocJittered <- jitter(dfgeary$Loc, factor = 0.5) -->
<!-- points( -->
<!--   dfgeary$LocJittered, -->
<!--   dfgeary$Value, -->
<!--   cex = 0.5, -->
<!--   pch = 19, -->
<!--   col = "grey", -->
<!--   xpd = TRUE -->
<!-- ) -->

<!-- #Add mean points -->
<!-- points( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixgearyAtEnd, 2, mean), -->
<!--   pch = 19, -->
<!--   cex = 1.25 -->
<!-- ) -->
<!-- text( -->
<!--   x = 1:length(temporalKnowledge) + 0.2, -->
<!--   y = apply(matrixgearyAtEnd, 2, mean) - maxy / 30, -->
<!--   labels = round(apply(matrixgearyAtEnd, 2, mean), digit = 2), -->
<!--   cex = 1.25 -->
<!-- ) -->

<!-- #x-axis -->
<!-- axis( -->
<!--   side = 1, -->
<!--   line = 0, -->
<!--   at = seq( -->
<!--     from = 1, -->
<!--     to = length(temporalKnowledge), -->
<!--     by = 1 -->
<!--   ), -->
<!--   labels = temporalKnowledge, -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 1, -->
<!--   line = 2.5, -->
<!--   at = (length(temporalKnowledge) + 0.5 + 0.5) / 2, -->
<!--   text = "Spatio-temporal knowledge rate", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- #y-axis -->
<!-- axis( -->
<!--   side = 2, -->
<!--   line = 0, -->
<!--   at = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   labels = seq(from = 0, to = maxy, by = maxy / 5), -->
<!--   tcl = -0.25, -->
<!--   las = 1, -->
<!--   cex.axis = 1.5 -->
<!-- ) -->
<!-- mtext( -->
<!--   side = 2, -->
<!--   line = 3, -->
<!--   at = maxy / 2, -->
<!--   text = "Geary's index", -->
<!--   cex = 2, -->
<!--   font = 2 -->
<!-- ) -->

<!-- par(mar = c(0, 0, 0, 0), mgp = c(2, 0.5, 0)) -->
<!-- emptyPlot() -->
<!-- geary_legendIMG <- readPNG("FIG/Geary_legend.png") -->
<!-- addImg(geary_legendIMG, -->
<!--        x = 0.5, -->
<!--        y = 0.5, -->
<!--        width = 0.5) -->

<!-- ``` -->

<!-- ### Cognitive foraging efficiency is (not? -> awaiting results) affected by tree distribution engineering -->

<!-- ```{r figefficiency, fig.width=7, fig.height=7, include=TRUE, warning = FALSE, fig.cap="Foraging efficiency on emerging patterns favours/disfavours XXNULL, INTERMEDIATE...XXX cognition | Spatio-temporal knowledge rate indicates the proportion of trees that wass known by the forager from which the distribution of trees at end of simulation was used. The agent type indicates the agents that foraged in the environment (separately from each other). Null agents have no spatio-temporal knowledge. Intermediate agents know all of the trees, and omniscient agents know all trees. During these simulations, no dispersal occurred."} -->
<!-- plotEfficiency <- -->
<!--   ggplot(tableEfficiencyAgent_nodispersal, aes(x = Knowledge, y = Value)) + -->
<!--   geom_boxplot(aes(fill = Agent)) + -->
<!--   stat_summary( -->
<!--     aes(group = Agent), -->
<!--     fun = "mean", -->
<!--     geom = "point", -->
<!--     shape = 19, -->
<!--     size = 2, -->
<!--     position = position_dodge(0.75) -->
<!--   ) + -->
<!--   scale_fill_manual(values = c("white", "grey80", "grey90")) + -->
<!--   theme_bw() + -->
<!--   theme( -->
<!--     #panel.border = element_blank(), -->
<!--     axis.line = element_line(colour = "black"), -->
<!--     axis.text = element_text(size = 12), -->
<!--     axis.title = element_text(size = 14, face = "bold") -->
<!--   ) + -->
<!--   xlab("Efficiency") + -->
<!--   ylab("Spatio-temporal knowledge rate") + -->
<!--   labs(fill = "Agent type") -->

<!-- plotEfficiency -->

<!-- ``` -->

# Discussion

The environment is shaped by the species that inhabit it. The destructive behaviour of some animals, such as forest elephants [REF], can lead to blatant changes, but more elusive - yet no less ecologically relevant - engineering can also occur over longer time scales. Using an agent-based model, we have illustrated the role of frugivores in shaping the distribution of fruit plants through zoochory. We showed that...


[TO BE UPDATED]

# Acknowledgements

Simulations were ran on the HPC cluster of the Edmund Mach Foundation. We thank Louise Riotte-Lambert and Kavel Ozturk for discussion on the model.

# Funding

B.R. was supported by the Gordon and Betty Moore Foundation.

# Declaration of conflict of interest

We declare having no conflict of interest.

# Data and code availability

The code used to generate the data and perform the analyses is available at XXXX. We provide it with the singularity image, which would allow the user to access the computing environment used to run the simulations in the first place.

\beginsupplement

\clearpage

<!-- # (APPENDIX) Appendix {-} -->
# Appendix

<!-- ## What distance to calculate reticulation? -->

<!-- We tested four different distance to use for establishing the Relative Neighbouring Graph, namely, the Euclidean distance (distance of norm 2, used for basics geometry), the Manhattan distance (distance of norm 1, usually adapted to grid system), the Chebychev distance (distance of infinite norm), or the Canberra distance (Weighted manhattan distance). We considered point patterns corresponding to a homogeneous distribution (Poisson distribution), a heterogeneous distribution (Poisson distribution of clusters of trees), and of route networks (see Figure \@ref(fig:figDistribution), at high density). The distribution resembling a route network was obtained by modelling ten correlated random walk of 100 steps ("simm.crw" function of the *adehabitatLT* package [@adehabitatLT], with a scaling parameter, to determine step length, of 20 su, and a concentration parameter, relative to the correlation in heading, of 0.9). All distributions included 1000 trees within a square map of side length 1000 su. We repeated measurements on `r numberOfRepetitionsForMetrics` maps for each distribution type. It emphasizes that the Manhattan distance seems the most pertinent distance to clearly distinguish between distribution reticulation, with more reticulated distributions corresponding to route network-like distributions. -->

<!-- ```{r figDistance, fig.width=7, fig.height=8, include=TRUE, warning = FALSE, fig.cap="Reticulation index as a function of the distance used for calculation | Distribution: Homo. = homogeneous, Hetero. = Heterogeneous, Route = Route network-like."} -->
<!-- theme_set(theme_bw(15)) -->
<!-- distanceReticulation.ggplot -->
<!-- ``` -->

<!-- ## Quadrat size estimation -->

<!-- As specified by @lloyd1967mean, quadrat size should little matter for calculation provided sufficient biological relevance in a homogeneous distribution (*to verify, written based on my memories of it*). Estimating such "biological relevance" in a completely artefactual world is thus rendered difficult. We thus considered different quadrat sizes (paste(patchSizeToTest, collapse=", ") su), and calculated patchiness for r numberPatchinessRepetition homogeneous or heterogeneous distribution (see below for definition) when a square map of side 1000 su contained 1000 trees. -->

## Using patchiness and alignment to characterise spatial point patterns

We provide below evidence that the two metrics, namely *patchiness* and *alignment*, allows for distinguishing between homogeneous, heterogeneous and route point patterns. In both the low and high density, we considered 1/10 of the number of trees as the number of clusters for the heterogeneous distribution (i.e. 10 clusters at low density, 100 at high density). Around these clusters of strictly equivalent size, trees were distributed according to a Gaussian distribution (both for the *x* and *y* axis) of variance 50 su. The distribution resembling a route network was obtained by modelling one (low density) to ten (high density) correlated random walks of 100 steps ("simm.crw" function of the *adehabitatLT* package, @adehabitatLT, with a scaling parameter, to determine step length, of 20 su, and a concentration parameter, relative to the correlation in heading, of 0.9). We calculated the two metrics on `r numberOfRepetitionsForMetrics` distributions. Note that, because we are in "perfect" conditions, we considered a neighbourhood for the alignment of 0 su, implying that the calculation was based on the triangle formed with the two closest trees for each tree.

|   Homogeneous distributions are identified by a low patchiness and a low alignment. Heterogeneoous distributions are identified by an intermediate patchiness and a low alignment. Finally route point organisation is evidenced by a high patchiness and a high alignment (Figure \ref{fig:figMetrics}). This pattern is robust to density variations, although absolute differences in the indices shrink with density increase (Figure \ref{fig:figMetrics}).

```{r figDistribution, fig.width=7, fig.height=8, include=TRUE, warning = FALSE, fig.cap="Simulated spatial distributions to investigate metrics value | Distribution: Homo. = homogeneous, Hetero. = Heterogeneous, Route = Route network-like. Tree population size: Low = 100 trees, High = 1000 trees, within a square map of side length 1000 su."}

distribution.ggplot +
  theme(    
    strip.text.x = element_text(face = "bold", colour = "black"),
    strip.text.y = element_text(face = "bold", colour = "black"),
    strip.background = element_rect(colour = NA, fill = "white"),
            panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
    ) +
  scale_y_continuous(breaks = extended_breaks(n = 4), minor_breaks = extended_breaks(n = 6*4)) +
  scale_x_continuous(breaks = extended_breaks(n = 4), minor_breaks = extended_breaks(n = 6*4))

```

```{r figMetrics, fig.width=7, fig.height=6, include=TRUE, warning = FALSE, fig.cap="Patchiness and alignment allows for identifying spatial distributions at low (100 trees) or high (1000 trees) tree population size | Results are based from simulated data following a homogeneous (Homo.), heterogeneous (Hetero.) or route network-like (Route) distribution. The mean value is depicted by the black dot and the text. The shape of the distribution is depicted by the half-violin plot, right to raw jittered data."}
  
global.ggplotLow <-
  ggplot(global.df_rdc %>% filter(Density == "Low" & (Index == "Patchiness" | Index == "Alignment")), aes(x = Distribution, Value, fill = Distribution)) +
  facet_grid(Index ~ ., scales = "free")+
  #geom_jitter(aes(color = Distribution),
  #width=0.15, alpha = 0.6)+
  geom_violin(position = position_nudge(x = 0, y = 0)) +
  
  # geom_flat_violin(position = position_nudge(x = .2, y = 0)) +
  # geom_jitter(aes(color = Distribution),
  #             width=0.15, alpha = 0.6)+
  
  stat_summary(
    #fun.data = give.n,
    geom = "text",
    fun.y = "mean",
    size = 3,
    vjust = -0.5,
    aes(label = round(after_stat(y), 2))
  ) +
  stat_summary(
    geom = "point",
    fun.y = "mean",
    size = 2,
    shape = 19
  ) +
  labs(x = "DISTRIBUTION", y = "VALUE") +
  ggtitle("Low") +
  #scale_y_continuous(sec.axis = sec_axis(~ . , name = "INDEX", breaks = NULL, labels = NULL)) +#, guide=guide_axis(position="left")
  #scale_x_discrete(sec.axis = sec_axis(~ . , name = "DENSITY", breaks = NULL, labels = NULL)) +
  # scale_fill_viridis(discrete = TRUE) +
  # scale_color_viridis(discrete = TRUE) +
  scale_fill_manual(values = c("white", "grey90", "grey80")) +
    theme(    
    strip.text.x = element_text(face = "bold", colour = "white"),
    strip.text.y = element_text(face = "bold", colour = "white"),
    strip.background = element_rect(colour = NA, fill = "white")
    ) +
  scale_y_continuous(breaks = extended_breaks(n = 4), minor_breaks = extended_breaks(n = 6*4))

global.ggplotHigh <-
  ggplot(global.df_rdc %>% filter(Density == "High" & (Index == "Patchiness" | Index == "Alignment")), aes(x = Distribution, Value, fill = Distribution)) +
  facet_grid(Index ~ ., scales = "free")+
  #geom_jitter(aes(color = Distribution),
  #width=0.15, alpha = 0.6)+
  geom_violin(position = position_nudge(x = 0, y = 0)) +
  
  # geom_flat_violin(position = position_nudge(x = .2, y = 0)) +
  # geom_jitter(aes(color = Distribution),
  #             width=0.15, alpha = 0.6)+
  
  stat_summary(
    #fun.data = give.n,
    geom = "text",
    fun.y = "mean",
    size = 3,
    vjust = -0.5,
    aes(label = round(after_stat(y), 2))
  ) +
  stat_summary(
    geom = "point",
    fun.y = "mean",
    size = 2,
    shape = 19
  ) +
  labs(x = "DISTRIBUTION", y = "") +
  ggtitle("High") +
  #scale_y_continuous(sec.axis = sec_axis(~ . , name = "INDEX", breaks = NULL, labels = NULL)) +#, guide=guide_axis(position="left")
  #scale_x_discrete(sec.axis = sec_axis(~ . , name = "DENSITY", breaks = NULL, labels = NULL)) +
  # scale_fill_viridis(discrete = TRUE) +
  # scale_color_viridis(discrete = TRUE) +
  scale_fill_manual(values = c("white", "grey90", "grey80")) +
  scale_y_continuous(breaks = extended_breaks(n = 4), minor_breaks = extended_breaks(n = 6*4))

library(ggpubr)
global.ggplot <- ggarrange(
  global.ggplotLow + guides(fill = "none"),
  global.ggplotHigh + guides(fill = "none"),
  ncol = 2
)
global.ggplot

```

\newpage